// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@neocord/utils
//   ../fs
//

import type { Class, Collection, Emitter } from "@neocord/utils";
import type { Stats } from "fs";
import type {
  Base,
  BaseResolvable,
  Client,
  ClientOptions,
  Guild,
  Job,
  Member,
  Message,
  PermissionResolvable,
  SweeperJobOptions,
  TextBasedChannel,
  User
} from "neocord";

declare module "neocord" {
  interface Client {
    handlers: Map<string, ComponentHandler>;
  }
}

export class ComponentHandler<T extends EnjoComponent = EnjoComponent> extends Emitter {
  /**
   * The components that were loaded by this handler.
   * @type {Collection}
   */
  readonly store: Collection<string, T>;
  /**
   * The name of this handler.
   * @type {string}
   */
  readonly name: string;
  /**
   * The filter to use when loading files.
   * @type {LoadFilter}
   */
  loadFilter: LoadFilter;
  /**
   * The class that this component is loading.
   * @type {Class}
   */
  class: Class<T>;
  /**
   * The directory to load files from.
   * @type {string}
   */
  directory: string;

  /**
   * @param {Enjo} client The client instance.
   * @param {string} name The name of this handler. Used for declaring the directory.
   * @param {HandlerOptions} options The options.
   */
  constructor(client: Enjo, name: string, options?: HandlerOptions);

  /**
   * The client instance.
   * @type {Enjo}
   */
  get client(): Enjo;

  /**
   * Get a component from the store.
   * @param {ComponentHandler} resolvable The component to get.
   * @returns {?EnjoComponent}
   */
  get(resolvable: ComponentResolvable<T>): T | null;

  /**
   * Removes a component from the store.
   * @param {ComponentResolvable} resolvable The component to remove.
   * @param {boolean} emit Whether to emit the "removed" event.
   * @returns {boolean}
   */
  remove(resolvable: ComponentResolvable<T>, emit?: boolean): T | null;

  /**
   * Loads a component.
   * @param {string} dir The directory of the component.
   * @param {string[]} file The path to the file, relative to the parent directory.
   * @param {boolean} [reload=false] Whether we're reloading a component.
   */
  load(dir: string, file: string[], reload?: boolean): Promise<T | null>;

  /**
   * Loads all components in the provided directory.
   * @param {string} [dir] The directory to read.
   * @returns {Promise<number>} The number of components loaded.
   */
  loadAll(dir?: string): Promise<number>;

  /**
   * Defines the .toString behavior of this handler.
   * @returns {string}
   */
  toString(): string;

  /**
   * Adds a new component to the store.
   * @param {*} component The component to add.
   * @param {boolean} reload Whether the component was reloaded.
   * @returns {EnjoComponent | null}
   */
  protected _add(component: unknown, reload?: boolean): T | null;
}

export type ComponentResolvable<C extends EnjoComponent = EnjoComponent> = BaseResolvable<C>;
export type LoadFilter = (path: string, stats: Stats) => boolean;

export interface HandlerOptions {
  directory?: string;
  class?: Class<EnjoComponent>;
  loadFilter?: LoadFilter;
}

export class Command extends EnjoComponent<CommandOptions> {
  /**
   * The invoke triggers.
   * @type {string[]}
   */
  triggers: string[];
  /**
   * Whether to start typing before running this command.
   * @type {boolean}
   */
  typing: boolean;
  /**
   * The type of channel this command can be ran in.
   * @type {ChannelType}
   */
  channel?: ChannelType;
  /**
   * The permissions needed for this command.
   * @type {CommandPermissions}
   */
  permissions: Required<CommandPermissions>;

  /**
   * @param {Enjo} client The client instance.
   * @param {CommandOptions} options The command options.
   */
  constructor(client: Enjo, options: CommandOptions);

  /**
   * The ratelimit options.
   * @type {RatelimitOptions}
   */
  get ratelimit(): Required<RatelimitOptions>;

  /**
   * Called whenever one of the triggers is invoked.
   * @param {Context} ctx The context.
   * @param {Dictionary} args Parsed arguments.
   */
  exec(ctx: Context, args: Dictionary): unknown;
}

export type ExampleGetter = (prefix: string) => string[];
export type MissingPermissionResolver = (ctx: Context) => null | unknown;
export type ChannelType = "guild" | "dm";
export type RatelimitType = ("ch" | "channel") | ("usr" | "user") | ("g" | "guild");

export interface RatelimitOptions {
  /**
   * Whether to stack the reset cooldown if the target is already limited.
   * @type {boolean}
   */
  readonly stack?: boolean;
  /**
   * The amount of invokes before getting limited.
   * @type {number}
   * @example
   * 2
   */
  readonly bucket?: number;
  /**
   * The amount of time before the ratelimit resets.
   * @type {number | string}
   * @example
   * "30s"
   */
  readonly reset: number;
  /**
   * The type of ratelimit.
   * Either "user", "guild", or "channel".
   * @type {RatelimitType}
   */
  readonly type?: RatelimitType;
}

export interface CommandDescription {
  /**
   * Description content.
   * @type {string}
   * @example
   * "Bans the provided member(s)"
   */
  readonly content: string;
  /**
   * Extended description content.
   * @type {string}
   * @example
   * [
   *  "Bans up to 10 members for a certain reason, you can also provide a duration.",
   *  "Example: `!ban @2D @aesthetical garbage people --duration 10m`"
   * ]
   */
  readonly extended?: string | string[];
}

export interface CommandPermissions {
  /**
   * Permissions the invoker needs to run this command.
   * @type {PermissionResolvable | MissingPermissionResolver}
   * @example
   * ["BanMembers"]
   */
  readonly invoker?: PermissionResolvable | MissingPermissionResolver;
  /**
   * Permissions the client needs for this command to be ran.
   * @type {PermissionResolvable | MissingPermissionResolver}
   * @example
   * ["BanMembers"]
   */
  readonly client?: PermissionResolvable | MissingPermissionResolver;
  /**
   * Whether the invoker has to be the bot owner to use this command.
   * @type {boolean}
   */
  readonly botOwner?: boolean;
  /**
   * Whether the invoker has to be the guild owner to use this command.
   * @type {boolean}
   */
  readonly guildOwner?: boolean;
}

export interface CommandOptions extends ComponentOptions {
  /**
   * The triggers of this command. You need at least one trigger for the command to be invokable.
   * @type {string[]}
   * @example
   * ["ping", "latency"]
   */
  readonly triggers?: string[];
  /**
   * The description of this command.
   * @type {string | CommandDescription}
   * @example
   * {
   *   content: "Bans the provided member(s)",
   *   extended: [
   *    "Bans up to 10 members for a certain reason, you can also provide a duration.",
   *    "Example: `!ban @2D @aesthetical garbage people --duration 10m`"
   *   ]
   * }
   */
  readonly description?: string | CommandDescription;
  /**
   * Example usages of this command.
   * @type {string | ExampleGetter}
   * @example
   * (prefix) => [
   *  `${prefix}help ping`
   * ]
   */
  readonly examples?: any[] | ExampleGetter;
  /**
   * The permissions that this command needs.
   * @type {CommandPermissions}
   * @example
   * {
   *   invoker: Permission.BanMembers,
   *   client: Permission.BanMembers
   * }
   */
  readonly permissions?: CommandPermissions;
  /**
   * The type of channel this command can run in.
   * @type {ChannelType}
   * @example
   * "guild"
   */
  readonly channel?: ChannelType;
  /**
   * This commands usage.
   * @type {string}
   * @example
   * "[command name]"
   */
  readonly usage?: string;
  /**
   * Whether to start typing before running the command.
   * @type {boolean}
   */
  readonly typing?: boolean;
  /**
   * The ratelimit type.
   * @type {string | RatelimitOptions}
   * @example
   * {
   *   ratelimit: "guild:4/3s",
   *   ratelimit: {
   *     bucket: 4,
   *     reset: 3e4,
   *     type: "guild"
   *   }
   * }
   */
  readonly ratelimit?: string | RatelimitOptions;
}

export class CommandHandler extends ComponentHandler<Command> {
  /**
   * The commands dispatcher.
   * @type {CommandDispatcher}
   */
  readonly dispatcher: CommandDispatcher;

  /**
   * @param {Enjo} client The client instance.
   * @param {HandlerOptions} options The handler options.
   */
  constructor(client: Enjo, options?: CommandHandlerOptions);

  /**
   * Adds a new command to the store.
   * @param {CommandOptions} options The command options.
   * @param {CommandExec} exec The execution method.
   */
  add(options: CommandOptions, exec: CommandExec): Command;
}

export type CommandExec = (this: Command, ctx: Context, args: Dictionary) => unknown;

export interface CommandHandlerOptions extends HandlerOptions {
  dispatcher?: DispatcherOptions;
}

export class CommandDispatcher {
  /**
   * The ratelimit controller.
   * @type {RatelimitController}
   */
  readonly ratelimit: RatelimitController;
  /**
   * The context map.
   * @type {Collection<string, Context>}
   */
  readonly contexts: Collection<string, Context>;


  /**
   * @param {CommandHandler} handler The command handler.
   * @param {DispatcherOptions} [options] The dispatcher options.
   */
  constructor(handler: CommandHandler, options?: DispatcherOptions);

  /**
   * The client instance.
   * @type {Enjo}
   */
  get client(): Enjo;

  /**
   * The regexp for mention prefixes.
   * @type {RegExp}
   */
  get mentionPrefix(): RegExp;

  /**
   * The regexp for checking if the message content only contains the client mention.
   * @type {RegExp}
   */
  get aloneMention(): RegExp;

  /**
   * Handles an updated or new message.
   * @param {Message} message The message.
   */
  handle(message: Message): Promise<void>;
}

export type PrefixGetter = (this: Enjo, context: Context) => string | string[];

export interface DispatcherOptions {
  defaultRatelimit?: string | RatelimitOptions;
  passive?: boolean;
  mentionPrefix?: boolean;
  prefix?: (string | string[]) | PrefixGetter;
}

export class RatelimitController {
  /**
   * The ratelimit store.
   * @type {WeakMap}
   */
  readonly store: Map<string, RatelimitEntry>;

  /**
   * Returns the ratelimit key according to the ratelimit options.
   * @param {Message} message The message.
   * @param {RatelimitType} type
   */
  static getTarget(message: Message, type: RatelimitType): {
    id: string;
  };

  /**
   * Drip the ratelimit of a command.
   * @param {Message} message The message.
   * @param {Command} command The command.
   * @returns {Promise<number | boolean>}
   */
  drip(message: Message, command: Command): Promise<number | true>;
}

export interface RatelimitEntry {
  remaining: number;
  reset: number;
  exceeded?: true;
  timeout?: NodeJS.Timeout;
}

export class Context {
  /**
   * The message instance.
   * @type {Message}
   */
  readonly message: Message;
  /**
   * The current invocation.
   * @type {CurrentInvocation}
   */
  current?: CurrentInvocation;

  /**
   * @param {Message} message The message instance.
   */
  constructor(message: Message);

  /**
   * The channel that this message was sent in.
   * @type {boolean}
   */
  get channel(): TextBasedChannel;

  /**
   * The command invoker.
   * @type {User}
   */
  get author(): User;

  /**
   * The guild member that sent this message.
   * @type {?Member}
   */
  get member(): Member | null;

  /**
   * The guild that the message was sent in.
   * @type {?Guild}
   */
  get guild(): Guild | null;
}

export interface CurrentInvocation {
  args: string[];
  invoke: string;
  command: Command;
}

export class Listener extends EnjoComponent<ListenerOptions> {
  /**
   * The listener handler.
   * @type {ListenerOptions}
   */
  handler: ListenerHandler;
  /**
   * The event this listener is listening for.
   * @type {string}
   */
  event: string;
  /**
   * Whether this listener can only be ran once.
   * @type {boolean}
   */
  once: boolean;

  /**
   * @param {Enjo} client The client instance.
   * @param {ListenerOptions} options The listener options.
   */
  constructor(client: Enjo, options: ListenerOptions);

  /**
   * The emitter to use.
   * @type {boolean}
   */
  get emitter(): EventEmitterLike;

  /**
   * Called whenever the provided event is emitted.
   * @param {...*} args The passed arguments.
   */
  exec(...args: unknown[]): unknown;

  /**
   * Enables this listener.
   * @returns {this}
   */
  enable(): this;

  /**
   * Disables this listener.
   * @returns {this}
   */
  disable(): Readonly<this>;

  /**
   * Removes the listener from the emitter.
   * @returns {void}
   */
  _remove(): void;

  /**
   * Attaches the listener to the emitter.
   * @returns {void}
   */
  _listen(): void;
}

export interface ListenerOptions extends ComponentOptions {
  event: string;
  emitter?: EventEmitterLike | string;
  once?: boolean;
}

export class ListenerHandler extends ComponentHandler<Listener> {
  /**
   * The emitters to use when loading listeners.
   * @type {Dictionary<EventEmitterLike>}
   */
  emitters: Dictionary<EventEmitterLike>;

  /**
   * @param {Enjo} client The client instance.
   * @param {ListenerHandlerOptions} options The listener handler options.
   */
  constructor(client: Enjo, options: ListenerHandlerOptions);

  /**
   * Set the emitters to use when loading listeners.
   * @param {Dictionary<EventEmitterLike>} dict The emitters dict.
   * @param {boolean} merge Whether to merge the current dict with the new one.
   * @returns {this}
   */
  setEmitters(dict: Dictionary<EventEmitterLike>, merge?: boolean): this;

  /**
   * Removes a listener from the store.
   * @param {ComponentResolvable} resolvable The listener to remove.
   * @param {boolean} emit Whether to emit the "removed" event.
   * @returns {?Listener}
   */
  remove(resolvable: ComponentResolvable<Listener>, emit?: boolean): Listener | null;

  /**
   * Adds a new listener to the store.
   * @param {Listener} component The listener.
   * @param {boolean} [reload] Whether the listener was reloaded.
   * @returns {?Listener}
   */
  protected _add(component: Listener, reload?: boolean): Listener | null;
}

export interface ListenerHandlerOptions extends HandlerOptions {
  emitters?: Dictionary<EventEmitterLike>;
}

export class EnjoComponent<O extends ComponentOptions = ComponentOptions> extends Base {
  /**
   * The options for this component
   * @type {ComponentOptions}
   */
  readonly options: O;
  /**
   * The ID of this component.
   * @type {string}
   */
  id: string;
  /**
   * Whether this component is enabled.
   * @type {boolean}
   */
  enabled: boolean;
  /**
   * The handler that loaded this component.
   * @type {ComponentHandler}
   */
  handler: ComponentHandler<EnjoComponent>;
  /**
   * The path to this file.
   * @type {string}
   */
  path: string;

  /**
   * @param {Enjo} client The client instance.
   * @param {ComponentOptions} options The component options.
   */
  constructor(client: Enjo, options: O);

  /**
   * Ran when the client has become ready.
   */
  init(): unknown;

  /**
   * Disables this component.
   * @returns {Readonly<this>}
   */
  disable(): Readonly<this>;

  /**
   * Enables this component.
   * @returns {this}
   */
  enable(): this;

  /**
   * Update this component.
   * @param {Dictionary} data
   */
  _patch(data: Dictionary): this;
}

export interface ComponentOptions {
  id?: string;
  enabled?: boolean;
}

export const ContextJob: (options: SweeperJobOptions) => typeof Job;

export class Enjo extends Client {
  /**
   * All handlers that are attached to this client.
   * @type {Map<string, ComponentHandler>}
   */
  readonly handlers: Map<string, ComponentHandler>;
  /**
   * The owners of this bot.
   * @type {string}
   */
  owners: ReadonlySet<User>;
  /**
   * The directory to use when loading components.
   * @type {string}
   */
  directory: string;
  /**
   * The options provided to this client.
   */
  options: EnjoOptions;

  /**
   * @param {EnjoOptions} [options] The options
   */
  constructor(options?: EnjoOptions);
}

export interface EnjoOptions extends ClientOptions {
  /**
   * The owners of this bot.
   * @type {Set<string> | string[]}
   */
  owners?: Set<string> | string[];
  /**
   * Whether to fetch the owners, should be 'true' if you're not caching users.
   * @type {boolean}
   */
  fetchOwners?: boolean;
  /**
   * The directory to load from.
   * @type {string}
   */
  directory?: string;
  /**
   * Whether to auto load all handlers.
   * @type {boolean}
   */
  autoLoad?: boolean;
}

